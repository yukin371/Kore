// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.0--rc2
// source: api/proto/kore.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Kore_CreateSession_FullMethodName         = "/kore.Kore/CreateSession"
	Kore_GetSession_FullMethodName            = "/kore.Kore/GetSession"
	Kore_ListSessions_FullMethodName          = "/kore.Kore/ListSessions"
	Kore_CloseSession_FullMethodName          = "/kore.Kore/CloseSession"
	Kore_SendMessage_FullMethodName           = "/kore.Kore/SendMessage"
	Kore_ExecuteCommand_FullMethodName        = "/kore.Kore/ExecuteCommand"
	Kore_LSPComplete_FullMethodName           = "/kore.Kore/LSPComplete"
	Kore_LSPDefinition_FullMethodName         = "/kore.Kore/LSPDefinition"
	Kore_LSPHover_FullMethodName              = "/kore.Kore/LSPHover"
	Kore_LSPReferences_FullMethodName         = "/kore.Kore/LSPReferences"
	Kore_LSPRename_FullMethodName             = "/kore.Kore/LSPRename"
	Kore_LSPDiagnostics_FullMethodName        = "/kore.Kore/LSPDiagnostics"
	Kore_SubscribeEvents_FullMethodName       = "/kore.Kore/SubscribeEvents"
	Kore_CreateVirtualDocument_FullMethodName = "/kore.Kore/CreateVirtualDocument"
	Kore_UpdateVirtualDocument_FullMethodName = "/kore.Kore/UpdateVirtualDocument"
	Kore_CloseVirtualDocument_FullMethodName  = "/kore.Kore/CloseVirtualDocument"
)

// KoreClient is the client API for Kore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Kore 服务定义
type KoreClient interface {
	// 会话管理
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error)
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error)
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error)
	// 消息流（双向流）
	SendMessage(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MessageRequest, MessageResponse], error)
	// 命令执行（流式输出）
	ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandOutput], error)
	// LSP 请求
	LSPComplete(ctx context.Context, in *LSPCompleteRequest, opts ...grpc.CallOption) (*LSPCompleteResponse, error)
	LSPDefinition(ctx context.Context, in *LSPDefinitionRequest, opts ...grpc.CallOption) (*LSPDefinitionResponse, error)
	LSPHover(ctx context.Context, in *LSPHoverRequest, opts ...grpc.CallOption) (*LSPHoverResponse, error)
	LSPReferences(ctx context.Context, in *LSPReferencesRequest, opts ...grpc.CallOption) (*LSPReferencesResponse, error)
	LSPRename(ctx context.Context, in *LSPRenameRequest, opts ...grpc.CallOption) (*LSPRenameResponse, error)
	LSPDiagnostics(ctx context.Context, in *LSPDiagnosticsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LSPDiagnosticEvent], error)
	// 事件订阅
	SubscribeEvents(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error)
	// 虚拟文档管理
	CreateVirtualDocument(ctx context.Context, in *CreateVirtualDocRequest, opts ...grpc.CallOption) (*CreateVirtualDocResponse, error)
	UpdateVirtualDocument(ctx context.Context, in *UpdateVirtualDocRequest, opts ...grpc.CallOption) (*UpdateVirtualDocResponse, error)
	CloseVirtualDocument(ctx context.Context, in *CloseVirtualDocRequest, opts ...grpc.CallOption) (*CloseVirtualDocResponse, error)
}

type koreClient struct {
	cc grpc.ClientConnInterface
}

func NewKoreClient(cc grpc.ClientConnInterface) KoreClient {
	return &koreClient{cc}
}

func (c *koreClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, Kore_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, Kore_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, Kore_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseSessionResponse)
	err := c.cc.Invoke(ctx, Kore_CloseSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) SendMessage(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MessageRequest, MessageResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Kore_ServiceDesc.Streams[0], Kore_SendMessage_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MessageRequest, MessageResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_SendMessageClient = grpc.BidiStreamingClient[MessageRequest, MessageResponse]

func (c *koreClient) ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandOutput], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Kore_ServiceDesc.Streams[1], Kore_ExecuteCommand_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CommandRequest, CommandOutput]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_ExecuteCommandClient = grpc.ServerStreamingClient[CommandOutput]

func (c *koreClient) LSPComplete(ctx context.Context, in *LSPCompleteRequest, opts ...grpc.CallOption) (*LSPCompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LSPCompleteResponse)
	err := c.cc.Invoke(ctx, Kore_LSPComplete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) LSPDefinition(ctx context.Context, in *LSPDefinitionRequest, opts ...grpc.CallOption) (*LSPDefinitionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LSPDefinitionResponse)
	err := c.cc.Invoke(ctx, Kore_LSPDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) LSPHover(ctx context.Context, in *LSPHoverRequest, opts ...grpc.CallOption) (*LSPHoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LSPHoverResponse)
	err := c.cc.Invoke(ctx, Kore_LSPHover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) LSPReferences(ctx context.Context, in *LSPReferencesRequest, opts ...grpc.CallOption) (*LSPReferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LSPReferencesResponse)
	err := c.cc.Invoke(ctx, Kore_LSPReferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) LSPRename(ctx context.Context, in *LSPRenameRequest, opts ...grpc.CallOption) (*LSPRenameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LSPRenameResponse)
	err := c.cc.Invoke(ctx, Kore_LSPRename_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) LSPDiagnostics(ctx context.Context, in *LSPDiagnosticsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LSPDiagnosticEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Kore_ServiceDesc.Streams[2], Kore_LSPDiagnostics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LSPDiagnosticsRequest, LSPDiagnosticEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_LSPDiagnosticsClient = grpc.ServerStreamingClient[LSPDiagnosticEvent]

func (c *koreClient) SubscribeEvents(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Kore_ServiceDesc.Streams[3], Kore_SubscribeEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_SubscribeEventsClient = grpc.ServerStreamingClient[Event]

func (c *koreClient) CreateVirtualDocument(ctx context.Context, in *CreateVirtualDocRequest, opts ...grpc.CallOption) (*CreateVirtualDocResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVirtualDocResponse)
	err := c.cc.Invoke(ctx, Kore_CreateVirtualDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) UpdateVirtualDocument(ctx context.Context, in *UpdateVirtualDocRequest, opts ...grpc.CallOption) (*UpdateVirtualDocResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVirtualDocResponse)
	err := c.cc.Invoke(ctx, Kore_UpdateVirtualDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koreClient) CloseVirtualDocument(ctx context.Context, in *CloseVirtualDocRequest, opts ...grpc.CallOption) (*CloseVirtualDocResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseVirtualDocResponse)
	err := c.cc.Invoke(ctx, Kore_CloseVirtualDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KoreServer is the server API for Kore service.
// All implementations must embed UnimplementedKoreServer
// for forward compatibility.
//
// Kore 服务定义
type KoreServer interface {
	// 会话管理
	CreateSession(context.Context, *CreateSessionRequest) (*Session, error)
	GetSession(context.Context, *GetSessionRequest) (*Session, error)
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error)
	// 消息流（双向流）
	SendMessage(grpc.BidiStreamingServer[MessageRequest, MessageResponse]) error
	// 命令执行（流式输出）
	ExecuteCommand(*CommandRequest, grpc.ServerStreamingServer[CommandOutput]) error
	// LSP 请求
	LSPComplete(context.Context, *LSPCompleteRequest) (*LSPCompleteResponse, error)
	LSPDefinition(context.Context, *LSPDefinitionRequest) (*LSPDefinitionResponse, error)
	LSPHover(context.Context, *LSPHoverRequest) (*LSPHoverResponse, error)
	LSPReferences(context.Context, *LSPReferencesRequest) (*LSPReferencesResponse, error)
	LSPRename(context.Context, *LSPRenameRequest) (*LSPRenameResponse, error)
	LSPDiagnostics(*LSPDiagnosticsRequest, grpc.ServerStreamingServer[LSPDiagnosticEvent]) error
	// 事件订阅
	SubscribeEvents(*SubscribeRequest, grpc.ServerStreamingServer[Event]) error
	// 虚拟文档管理
	CreateVirtualDocument(context.Context, *CreateVirtualDocRequest) (*CreateVirtualDocResponse, error)
	UpdateVirtualDocument(context.Context, *UpdateVirtualDocRequest) (*UpdateVirtualDocResponse, error)
	CloseVirtualDocument(context.Context, *CloseVirtualDocRequest) (*CloseVirtualDocResponse, error)
	mustEmbedUnimplementedKoreServer()
}

// UnimplementedKoreServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKoreServer struct{}

func (UnimplementedKoreServer) CreateSession(context.Context, *CreateSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedKoreServer) GetSession(context.Context, *GetSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedKoreServer) ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedKoreServer) CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseSession not implemented")
}
func (UnimplementedKoreServer) SendMessage(grpc.BidiStreamingServer[MessageRequest, MessageResponse]) error {
	return status.Error(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedKoreServer) ExecuteCommand(*CommandRequest, grpc.ServerStreamingServer[CommandOutput]) error {
	return status.Error(codes.Unimplemented, "method ExecuteCommand not implemented")
}
func (UnimplementedKoreServer) LSPComplete(context.Context, *LSPCompleteRequest) (*LSPCompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LSPComplete not implemented")
}
func (UnimplementedKoreServer) LSPDefinition(context.Context, *LSPDefinitionRequest) (*LSPDefinitionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LSPDefinition not implemented")
}
func (UnimplementedKoreServer) LSPHover(context.Context, *LSPHoverRequest) (*LSPHoverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LSPHover not implemented")
}
func (UnimplementedKoreServer) LSPReferences(context.Context, *LSPReferencesRequest) (*LSPReferencesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LSPReferences not implemented")
}
func (UnimplementedKoreServer) LSPRename(context.Context, *LSPRenameRequest) (*LSPRenameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LSPRename not implemented")
}
func (UnimplementedKoreServer) LSPDiagnostics(*LSPDiagnosticsRequest, grpc.ServerStreamingServer[LSPDiagnosticEvent]) error {
	return status.Error(codes.Unimplemented, "method LSPDiagnostics not implemented")
}
func (UnimplementedKoreServer) SubscribeEvents(*SubscribeRequest, grpc.ServerStreamingServer[Event]) error {
	return status.Error(codes.Unimplemented, "method SubscribeEvents not implemented")
}
func (UnimplementedKoreServer) CreateVirtualDocument(context.Context, *CreateVirtualDocRequest) (*CreateVirtualDocResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVirtualDocument not implemented")
}
func (UnimplementedKoreServer) UpdateVirtualDocument(context.Context, *UpdateVirtualDocRequest) (*UpdateVirtualDocResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVirtualDocument not implemented")
}
func (UnimplementedKoreServer) CloseVirtualDocument(context.Context, *CloseVirtualDocRequest) (*CloseVirtualDocResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseVirtualDocument not implemented")
}
func (UnimplementedKoreServer) mustEmbedUnimplementedKoreServer() {}
func (UnimplementedKoreServer) testEmbeddedByValue()              {}

// UnsafeKoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KoreServer will
// result in compilation errors.
type UnsafeKoreServer interface {
	mustEmbedUnimplementedKoreServer()
}

func RegisterKoreServer(s grpc.ServiceRegistrar, srv KoreServer) {
	// If the following call panics, it indicates UnimplementedKoreServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Kore_ServiceDesc, srv)
}

func _Kore_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_CloseSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_SendMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KoreServer).SendMessage(&grpc.GenericServerStream[MessageRequest, MessageResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_SendMessageServer = grpc.BidiStreamingServer[MessageRequest, MessageResponse]

func _Kore_ExecuteCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KoreServer).ExecuteCommand(m, &grpc.GenericServerStream[CommandRequest, CommandOutput]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_ExecuteCommandServer = grpc.ServerStreamingServer[CommandOutput]

func _Kore_LSPComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).LSPComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_LSPComplete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).LSPComplete(ctx, req.(*LSPCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_LSPDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPDefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).LSPDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_LSPDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).LSPDefinition(ctx, req.(*LSPDefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_LSPHover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPHoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).LSPHover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_LSPHover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).LSPHover(ctx, req.(*LSPHoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_LSPReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).LSPReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_LSPReferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).LSPReferences(ctx, req.(*LSPReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_LSPRename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPRenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).LSPRename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_LSPRename_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).LSPRename(ctx, req.(*LSPRenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_LSPDiagnostics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LSPDiagnosticsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KoreServer).LSPDiagnostics(m, &grpc.GenericServerStream[LSPDiagnosticsRequest, LSPDiagnosticEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_LSPDiagnosticsServer = grpc.ServerStreamingServer[LSPDiagnosticEvent]

func _Kore_SubscribeEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KoreServer).SubscribeEvents(m, &grpc.GenericServerStream[SubscribeRequest, Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kore_SubscribeEventsServer = grpc.ServerStreamingServer[Event]

func _Kore_CreateVirtualDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVirtualDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).CreateVirtualDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_CreateVirtualDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).CreateVirtualDocument(ctx, req.(*CreateVirtualDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_UpdateVirtualDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVirtualDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).UpdateVirtualDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_UpdateVirtualDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).UpdateVirtualDocument(ctx, req.(*UpdateVirtualDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kore_CloseVirtualDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseVirtualDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoreServer).CloseVirtualDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kore_CloseVirtualDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoreServer).CloseVirtualDocument(ctx, req.(*CloseVirtualDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Kore_ServiceDesc is the grpc.ServiceDesc for Kore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Kore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kore.Kore",
	HandlerType: (*KoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _Kore_CreateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _Kore_GetSession_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _Kore_ListSessions_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _Kore_CloseSession_Handler,
		},
		{
			MethodName: "LSPComplete",
			Handler:    _Kore_LSPComplete_Handler,
		},
		{
			MethodName: "LSPDefinition",
			Handler:    _Kore_LSPDefinition_Handler,
		},
		{
			MethodName: "LSPHover",
			Handler:    _Kore_LSPHover_Handler,
		},
		{
			MethodName: "LSPReferences",
			Handler:    _Kore_LSPReferences_Handler,
		},
		{
			MethodName: "LSPRename",
			Handler:    _Kore_LSPRename_Handler,
		},
		{
			MethodName: "CreateVirtualDocument",
			Handler:    _Kore_CreateVirtualDocument_Handler,
		},
		{
			MethodName: "UpdateVirtualDocument",
			Handler:    _Kore_UpdateVirtualDocument_Handler,
		},
		{
			MethodName: "CloseVirtualDocument",
			Handler:    _Kore_CloseVirtualDocument_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendMessage",
			Handler:       _Kore_SendMessage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ExecuteCommand",
			Handler:       _Kore_ExecuteCommand_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LSPDiagnostics",
			Handler:       _Kore_LSPDiagnostics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeEvents",
			Handler:       _Kore_SubscribeEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/proto/kore.proto",
}
