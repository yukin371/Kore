# Phase 1: 工具调用优化 - 测试指南

**测试日期**: 2026-01-17
**版本**: feature/kore-optimization
**提交**: 46ecbc3

---

## 编译验证

```bash
✅ 编译成功
✅ 可执行文件: bin/kore.exe (23MB)
```

---

## 启动 TUI

```bash
.\bin\kore.exe chat --ui tui
```

**预期界面**:
- 状态栏显示 "○ 准备就绪"（灰色）
- 系统提示词已加载
- 工具指南已集成

---

## 测试场景

### 场景 1: 工具调用历史记录

**步骤**:
```
输入: 创建 hello.go 文件，内容是 println("Hello World")
按: Enter
```

**预期结果**:
- [ ] AI 调用 `write_file`
- [ ] 工具执行完成后，工具历史被记录
- [ ] 在下次 LLM 调用时，历史会包含在系统提示词中

**验证方法**:
```bash
# 检查是否调用了 write_file
# 观察工具执行历史（在下一轮对话时会体现）
```

---

### 场景 2: 避免重复读取（核心功能）

**步骤 A**:
```
1. 输入: 创建 hello.go
2. 确认文件创建成功

输入: hello.go 的内容是什么？
```

**预期结果**:
- [ ] **AI 从历史中读取**，不调用 `read_file`
- [ ] AI 说明："根据刚才创建的 hello.go..."
- [ ] 系统提示词中包含工具调用摘要

**步骤 B**:
```
输入: 创建 utils.go 文件，包含一个 add 函数
确认创建成功

输入: utils.go 的内容是什么？
```

**预期结果**:
- [ ] AI 从历史中读取 utils.go
- [ ] 不调用 `read_file`

---

### 场景 3: 智能文件缓存

**步骤**:
```
1. 输入: 创建 test.txt 文件，内容是 "Hello"
   （AI 调用 write_file）

2. 输入: test.txt 的内容是什么？
   （AI 应该从历史读取，显示 "Hello"）

3. 【关键测试】手动修改文件：
   在另一个编辑器中打开 test.txt
   修改内容为 "Hello World"

4. 输入: test.txt 的内容是什么？
```

**预期结果**:
- [ ] 第 2 步：AI 显示 "Hello"（从历史）
- [ ] 第 4 步：AI 检测到文件变化，重新读取
- [ ] AI 显示 "Hello World"（最新内容）
- [ ] 工具历史显示第二次读取操作

---

### 场景 4: 缓存失效机制

**步骤**:
```
1. 输入: 覆盖 hello.go，内容是 println("Updated")
   （AI 调用 write_file）

2. 输入: hello.go 的内容是什么？
```

**预期结果**:
- [ ] AI 显示 "println("Updated")"（从历史）
- [ ] 不调用 `read_file`

---

### 场景 5: 工具调用历史摘要

**观察点**:
在第二轮对话中，AI 的系统提示词应该包含：

```
## 最近工具调用

- [✓] write_file({"path": "hello.go"})
- [✓] read_file({"path": "test.txt"})
...
```

**验证方法**:
- 工具调用历史应该显示最近 10 次调用
- 失败的工具显示 "✗" 和错误信息
- 成功的工具显示 "✓"

---

## 成功标准

### 核心指标

- ✅ **不再重复读取**: AI 创建文件后，查询时不调用 `read_file`
- ✅ **智能缓存**: 外部修改文件后，AI 能检测到变化
- ✅ **历史记录**: 所有工具调用都被记录
- ✅ **摘要可见**: 工具调用历史包含在系统提示词中

### 对比修复前后

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| 创建文件后查询内容 | 反复调用 read_file | 从历史读取 ✅ |
| 外部修改文件 | 读到过期内容 | 检测变化重新读取 ✅ |
| 工具调用可见性 | 不可见 | 包含在系统提示词中 ✅ |

---

## 已知限制

1. **Parallel Tools 未启用**
   - 当前 `ParallelTools: false`
   - AI 仍然串行调用工具
   - 工具指南中提到并行调用，但实际执行是串行的
   - 这是预期的，未来可以启用

2. **历史长度限制**
   - 最多保留 50 条工具调用记录
   - GetSummary() 只显示最近 10 条
   - 这是为了管理内存

3. **缓存仅对 read_file**
   - 当前只有 `read_file` 使用缓存
   - `list_files` 和 `search_files` 未实现缓存
   - 因为这些工具返回目录列表/搜索结果，不是文件内容

---

## 测试报告模板

### 测试场景

- [ ] 场景 1: 工具调用历史记录
- [ ] 场景 2A: 避免重复读取（无外部修改）
- [ ] 场景 2B: 避免重复读取（多次查询）
- [ ] 场景 3: 智能文件缓存（外部修改检测）
- [ ] 场景 4: 缓存失效机制（写入后查询）
- [ ] 场景 5: 工具调用历史摘要

### 性能观察

- Token 使用: __________（观察是否减少）
- 响应速度: __________（是否仍然卡顿）
- 内存使用: __________（内存是否稳定）

### 发现的问题

1. ___________
2. ___________

---

## 快速测试命令

```bash
# 测试创建文件
.\bin\kore.exe chat --ui tui

# 快速测试序列
1. 创建 hello.go → 查看 → 应该不调用 read_file
2. 手动修改 hello.go → 查看 → 应该检测到变化
3. 创建 utils.go → 查看 → 应该不调用 read_file
```

---

**准备好测试了吗？** 🚀

运行 `.\bin\kore.exe chat --ui tui` 并按场景测试。

记录你的测试结果！
