# Kore 2.0 设计文档

**创建日期**: 2026-01-17
**版本**: 2.0.0-dev
**状态**: 设计阶段

---

## 目录

1. [项目概述](#项目概述)
2. [架构设计](#架构设计)
3. [核心组件](#核心组件)
4. [技术决策](#技术决策)
5. [安全考虑](#安全考虑)
6. [性能优化](#性能优化)

---

## 项目概述

### 目标

Kore 2.0 旨在成为**高性能的 OpenCode**，一个功能完整的 AI 编程代理，具备：

1. **多 Agent 系统**：build（完全访问）、plan（只读）、general（复杂任务）
2. **Client/Server 架构**：支持远程控制和多种客户端
3. **GUI 工作台**：以 CLI 为核心，提供类似 Dify 的可视化界面，接入各类创作工具（文案/设计/多媒体等）
4. **完整 LSP 集成**：代码补全、定义跳转、重构、诊断等
5. **多会话并行**：TUI 标签页 + 独立会话支持
6. **实时流式体验**：背压感知的事件系统
7. **虚拟文档支持**：代码预览与修正（先修后写）
8. **底层工具扩展**：将 Claude 的 skill 机制集成到工具调用链
9. **插件市场**：可视化管理与安装 MCP/skill 等扩展能力
10. **安全沙箱**：受限环境执行代码和命令
11. **多API聚合**：同时支持 OpenAI、Ollama 等 LLM 提供商

### 设计原则

- **Go 语言原生**：利用 Go 的并发、性能优势
- **模块化**：清晰的接口边界，易于测试和扩展
- **渐进增强**：从 MVP 开始，逐步添加高级功能
- **安全第一**：沙箱环境、权限控制、加密存储
- **用户体验**：实时反馈、流畅交互、优雅降级

---

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端层（多实例支持）                    │
├─────────────────────────────────────────────────────────────┤
│  GUI 工作台（以 CLI 为核心） │  TUI Client (标签页多会话)  │  CLI Client  │  未来：Web/Mobile │
└────────────┬─────────────────────────────────────────────────┘
             │ gRPC Bidirectional Streaming
             ▼
┌─────────────────────────────────────────────────────────────┐
│                      Session Manager                        │
│  - 会话生命周期管理                                          │
│  - 会话间状态隔离                                            │
│  - Agent 分配与切换（全局 + 会话级）                         │
│  - Event Bus（事件分发与订阅）                             │
└────────────┬─────────────────────────────────────────────────┘
             │
             ▼
┌─────────────────────────────────────────────────────────────┐
│                 Agent Runtime Core                          │
│          [ Execution Loop Controller / State Machine ]      │
│   Plan -> Code -> Execute -> Observe -> Decide -> Repeat   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                  │
│  │  Build   │  │  Plan    │  │ General  │                  │
│  │  Agent   │  │  Agent   │  │  Agent   │                  │
│  └──────────┘  └──────────┘  └──────────┘                  │
└────────────┬──────────┬─────────────────────────────────────┘
             │          │ Event / Log Stream (Real-time)
    ┌────────┼──────────┼─────────────┬──────────────┐
    ▼        ▼          ▼             ▼              ▼
┌────────┐ ┌──────────┐ ┌────────┐ ┌──────────┐ ┌──────────┐
│  LLM   │ │Environment│ │ LSP    │ │ Context  │ │ History  │
│Provider│ │& Sandbox │ │ Manager│ │ Manager  │ │ Manager  │
└────────┘ └──────────┘ └────────┘ └──────────┘ └──────────┘
           ▲
           │ (Execute & Capture Stderr/Stdout)
```

### 分层说明

#### 1. 客户端层

- **GUI 工作台**：以 CLI 为核心，提供可视化会话与工具面板，面向创作类工具接入
- **TUI Client**：Bubble Tea 框架，支持标签页、流式显示
- **CLI Client**：简洁的命令行界面
- **未来**：Web 客户端、移动端

#### 2. 会话管理层

- 会话生命周期：创建、切换、暂停、恢复、关闭
- 资源隔离：每个会话独立的环境、历史、状态
- Agent 管理：全局默认 + 会话级覆盖

#### 3. Agent 运行时核心

- **Loop Controller**：ReAct 循环引擎
- **状态机**：Planning → Executing → Observing → Reflecting → Done
- **Context Pruning**：智能上下文剪枝，避免 Token 爆炸

#### 4. 基础设施层

- **LLM Provider**：OpenAI、Ollama、其他兼容 API
- **Environment Manager**：本地执行、Docker 沙箱（未来）
- **LSP Manager**：单例模式，每种语言一个实例
- **Context Manager**：项目上下文加载与管理
- **History Manager**：对话历史持久化

---

## 核心组件

### 1. Agent Loop Controller

**职责**：实现自我修正的 ReAct 循环

**状态机**：
```
Planning → Executing → Observing → Reflecting → Done
                                           ↓
                                         Planning
```

**关键方法**：
```go
type LoopController struct {
    state       AgentState
    maxLoops    int
    currentLoop int
    history     *LoopHistory
    strategy    ContextStrategy  // 上下文剪枝策略
}

func (lc *LoopController) Run(ctx context.Context, userMessage string) error
func (lc *LoopController) plan(ctx context.Context, prompt string, iter *LoopIteration)
func (lc *LoopController) execute(ctx context.Context, iter *LoopIteration)
func (lc *LoopController) observe(ctx context.Context, iter *LoopIteration) bool
func (lc *LoopController) reflect(ctx context.Context, iter *LoopIteration) bool
```

**Context Pruning 策略**：
- 保留初始用户请求
- 最近 N 轮（默认 3）保留完整细节
- 更早的轮次摘要化（使用 LLM 总结）

### 2. Environment Manager

**职责**：安全执行命令 + 文件操作 + 虚拟文档

**接口设计**：
```go
type ExecutionEnvironment interface {
    // 命令执行
    Execute(ctx context.Context, cmd *Command) (*ExecutionResult, error)
    ExecuteStream(ctx context.Context, cmd *Command) (<-chan StreamEvent, error)

    // 文件操作
    WriteFile(ctx context.Context, path string, content []byte) error
    ReadFile(ctx context.Context, path string) ([]byte, error)
    Diff(ctx context.Context, path string, newContent []byte) (string, error)

    // 长运行进程管理
    StartBackgroundProcess(ctx context.Context, cmd *Command) (*ProcessHandle, error)
    KillProcess(ctx context.Context, pid int) error
    ListProcesses() []ProcessInfo

    // 虚拟文档（内存文件）
    CreateVirtualDocument(path, content string) (*VirtualDocument, error)
    UpdateVirtualDocument(path string, content string) error
    SyncVirtualDocument(path string) error  // 落盘
}
```

**虚拟文档工作流**：
1. Agent 生成代码 → 创建虚拟文档
2. LSP 诊断虚拟文档 → 修正错误
3. 确认无误 → Sync 落盘

### 3. LSP Manager

**职责**：管理 LSP 客户端连接，提供语言服务

**单例模式**：
- 每种语言（Go、Python、TypeScript）只启动一个 LSP 进程
- 所有会话共享 LSP 实例，通过 URI 隔离项目

**接口设计**：
```go
type LSPManager struct {
    servers     map[string]*LSPClient  // 单例：每种语言一个
    registry    *ServerRegistry
    virtualDocs map[string]*VirtualDocument
    mu          sync.RWMutex
}

type LanguageServer interface {
    // 基础能力
    Initialize(ctx context.Context, rootPath string) (*InitializeResult, error)
    Shutdown(ctx context.Context) error

    // 文档同步
    DidOpen(ctx context.Context, doc TextDocumentItem) error
    DidChange(ctx context.Context, doc VersionedTextDocumentIdentifier, changes []TextDocumentContentChangeEvent) error

    // 语言特性
    Complete(ctx context.Context, params CompletionParams) (*CompletionList, error)
    Definition(ctx context.Context, params DefinitionParams) ([]Location, error)
    References(ctx context.Context, params ReferenceParams) ([]Location, error)
    Hover(ctx context.Context, params HoverParams) (*Hover, error)
    Rename(ctx context.Context, params RenameParams) (*WorkspaceEdit, error)

    // 诊断
    PublishDiagnostics(ctx context.Context) (<-chan Diagnostic, error)
}
```

**LSP Server 注册**：
```go
var DefaultLSPRegistry = &ServerRegistry{
    servers: map[string]*ServerConfig{
        "go": {
            Language: "go",
            Command:  "gopls",
            Args:     []string{"serve"},
            InitializationOptions: map[string]interface{}{
                "completeUnimported": true,
            },
        },
        "python": {
            Language: "python",
            Command:  "pyright-langserver",
            Args:     []string{"--stdio"},
            InitializationOptions: map[string]interface{}{
                "pythonPath": "python", // Windows/Mac/Linux 需按环境调整
            },
        },
        "typescript": {
            Language: "typescript",
            Command:  "typescript-language-server",
            Args:     []string{"--stdio"},
        },
    },
}
```

### 4. Context Manager

**职责**：上下文缓存与文件变更感知，避免重复读取，保证多 Agent 看到一致内容

**核心思路**：
- 文件指纹（mtime + size + hash）作为缓存有效性判断
- 变更事件（FS watcher / 内部写入）驱动失效通知
- Agent 维护 `last_seen_fingerprint`，未变则不重读

**数据结构**：
```go
type Fingerprint struct {
    ModTime time.Time
    Size    int64
    Hash    string
}

type FileEntry struct {
    Path        string
    Fingerprint Fingerprint
    Content     string
    Summary     string
    Dirty       bool
}

type ContextManager struct {
    mu        sync.RWMutex
    entries   map[string]*FileEntry
    lastSeen  map[string]map[string]Fingerprint // agentID -> path -> fingerprint
    watcher   FileWatcher
    eventBus  *eventbus.EventBus
    env       *environment.ExecutionEnvironment
}
```

**读取流程**：
1. Agent 请求读取文件
2. 对比缓存指纹，未变直接返回缓存内容
3. 变更则重新读取、更新摘要与指纹
4. 记录 `last_seen_fingerprint`

**变更通知**：
- FS watcher 或工具写入触发 `file_changed` 事件（含来源：user/agent/tool）
- ContextManager 标记 `Dirty` 并向相关 Agent 推送 `context_invalidated`
- 下次读取时再拉取最新内容

### 5. Session Manager

**职责**：管理多个独立的对话会话

**数据结构**：
```go
type Session struct {
    ID            string
    Name          string
    CreatedAt     time.Time
    LastActiveAt  time.Time

    // Agent 配置
    AgentType     string          // "build", "plan", "general"
    AgentConfig   AgentConfig

    // 状态
    Status        SessionStatus   // "idle", "running", "paused", "closed"

    // 组件引用
    Agent         *agent.Agent
    ContextMgr    *context.ContextManager
    History       *history.History
    LSPManager    *lsp.LSPManager  // 共享单例

    // 隔离的数据
    Messages      []Message
    VirtualFiles  map[string]*VirtualDocument
    Environment   *environment.ExecutionEnvironment

    // 控制通道
    cancelCtx     context.CancelFunc
    pauseChan     chan struct{}
    resumeChan    chan struct{}
}
```

**会话持久化**：
- 使用 SQLite 存储（`modernc.org/sqlite`，纯 Go，无 CGO）
- 可选加密（AES-GCM）
- 流式读取大消息

### 6. Event Bus

**职责**：实时事件分发，支持背压

**设计**：
```go
type EventBus struct {
    mu          sync.RWMutex
    subscribers map[string][]*subscriber
    bufferSizes map[string]int  // 不同事件的缓冲大小
}

type subscriber struct {
    ch     chan Event
    filter func(Event) bool
}

// 背压感知的发布
func (eb *EventBus) Publish(ctx context.Context, event Event) error {
    for _, sub := range subscribers {
        select {
        case sub.ch <- event:
            // 正常发送
        case <-ctx.Done():
            return ctx.Err()  // 背压：超时
        }
    }
    return nil
}
```

**事件类型**：
- `llm_token`：LLM 生成的 token（缓冲 4096，不能丢）
- `tool_output`：工具输出（缓冲 100，可丢）
- `status`：状态变化（缓冲 10）
- `session_created`、`session_closed`：会话事件

---

## 技术决策

### 1. 通信协议：gRPC

**选择理由**：
- **双向流**：支持 Server → Client 的实时推送
- **性能**：基于 HTTP/2，多路复用
- **类型安全**：Protocol Buffers 定义接口
- **跨语言**：未来支持其他语言客户端

**本地 IPC 策略**：
1. **优先**：Unix Socket（类 Unix）/ Named Pipe（Windows）
2. **降级**：TCP localhost（支持 SSH 转发）
3. **配置**：`--listen-addr` 自动检测

### 2. 持久化：SQLite

**选择理由**：
- **嵌入式**：无需外部数据库
- **事务支持**：原子性写入
- **全文搜索**：SQLite FTS5 扩展
- **纯 Go 实现**：`modernc.org/sqlite`（无 CGO）

**Schema 设计**：
```sql
CREATE TABLE sessions (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    last_active_at INTEGER NOT NULL,
    agent_type TEXT NOT NULL,
    status TEXT NOT NULL,
    metadata JSON
);

CREATE TABLE messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL,
    role TEXT NOT NULL,
    content TEXT,  -- 可选加密
    timestamp INTEGER NOT NULL,
    metadata JSON,
    FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

CREATE INDEX idx_messages_session_id ON messages(session_id);
CREATE INDEX idx_messages_timestamp ON messages(timestamp);
```

**可选加密**：
```go
type SessionStore struct {
    db       *sql.DB
    cipher   *Cipher  // nil = 不加密
    enabled  bool
}
```

### 3. LSP 通信：JSON-RPC over Stdio

**选择理由**：
- **LSP 标准**：所有 LSP 服务器都支持
- **性能**：本地 IPC，零网络开销
- **简单**：无需额外依赖

**关键库**：
- `github.com/sourcegraph/go-lsp`：LSP 规范定义
- `github.com/sourcegraph/jsonrpc2`：JSON-RPC 2.0 实现

### 4. TUI 框架：Bubble Tea

**选择理由**：
- **Elm 架构**：Model → Update → View
- **强类型**：编译时保证
- **组件化**：易于测试和复用
- **生态丰富**：lipgloss（样式）、bubbles（组件）

---

## 安全考虑

### 1. 沙箱环境

**Phase 1（MVP）**：
- 路径遍历防护
- 命令注入防护
- 危险命令黑名单（`rm -rf`、`sudo`、`shutdown`）

**Phase 2**：
- Docker 沙箱支持
- 用户命名空间隔离
- 资源限制（CPU、内存、磁盘）

### 2. 权限控制

**Agent 类型**：
- **Build Agent**：完全访问权限
- **Plan Agent**：只读模式，拒绝文件写入
- **General Agent**：受限权限

**配置示例**：
```yaml
agents:
  build:
    allow_write: true
    allow_command: true
  plan:
    allow_write: false
    allow_command: false
    confirm_before_command: true
```

#### 工具边界与职责分离

**核心策略**：角色 -> 工具白名单 -> 作用域（路径/命令子集/API 资源）逐层收敛，默认拒绝未声明工具。

**权限矩阵示例**：
```yaml
roles:
  writer:
    tools: [read_file, web_fetch, summarize]
    scopes:
      paths: ["docs/**", "README.md"]
      commands: []
  designer:
    tools: [read_file, image_generate, asset_export]
    scopes:
      paths: ["assets/**", "docs/**"]
  builder:
    tools: [read_file, write_file, run_command, lsp_request]
    scopes:
      paths: ["internal/**", "cmd/**", "api/**"]
      commands: ["go", "rg", "git status"]
```

**执行约束**：
- ToolExecutor 强制校验 `role -> tools -> scopes`，不依赖 prompt 约束。
- 越权请求触发人工审批或由 Supervisor Agent 代执行。
- 全量审计：记录 Agent、工具、参数、结果。

**实现草图**：
```go
// ToolRequest carries the agent role and tool intent.
type ToolRequest struct {
    AgentID string
    Role    string
    Tool    string
    Params  map[string]string
}

type Scope struct {
    Paths    []string
    Commands []string
}

type Policy struct {
    Role  string
    Tools map[string]Scope
}

type PolicyEngine interface {
    Evaluate(req ToolRequest) (allowed bool, reason string)
}

type ToolExecutor struct {
    policy PolicyEngine
    audit  AuditLogger
}

func (e *ToolExecutor) Execute(req ToolRequest) (ToolResult, error) {
    allowed, reason := e.policy.Evaluate(req)
    if !allowed {
        e.audit.Deny(req, reason)
        return ToolResult{}, fmt.Errorf("permission denied: %s", reason)
    }
    e.audit.Allow(req)
    return e.runTool(req)
}
```

**校验流程**：
1. Session/Agent 标识传入 ToolRequest
2. PolicyEngine 校验角色、工具白名单、路径/命令作用域
3. 记录审计日志（允许/拒绝）
4. 通过后进入具体 Tool 运行

**策略配置示例**（`configs/policy.yaml`）：
```yaml
default:
  deny_by_default: true
  audit_level: summary

roles:
  writer:
    tools:
      read_file:
        paths: ["docs/**", "README.md"]
      web_fetch:
        allow: true
  builder:
    tools:
      read_file:
        paths: ["internal/**", "cmd/**", "api/**"]
      write_file:
        paths: ["internal/**", "cmd/**", "api/**"]
      run_command:
        commands: ["go", "rg", "git status"]
```

**审计日志格式**（JSON Lines）：
```json
{"ts":"2026-01-18T12:30:45Z","agent_id":"a-123","role":"builder","tool":"run_command","allowed":true,"reason":"","params":{"command":"go test ./..."},"session_id":"s-456"}
{"ts":"2026-01-18T12:31:10Z","agent_id":"a-789","role":"writer","tool":"write_file","allowed":false,"reason":"tool not allowed","params":{"path":"internal/main.go"},"session_id":"s-999"}
```

### 3. 加密存储

**可选加密**：
```yaml
session_db:
  path: ~/.kore/sessions.db
  enable_encryption: true
  encryption_key_env: KORE_DB_KEY
```

**实现**：
- AES-256-GCM
- 密钥从环境变量读取
- 权衡：加密会影响全文搜索性能

### 4. 通信安全

**本地 IPC**：
- Unix Socket / Named Pipe：文件权限控制
- TCP localhost：仅监听 127.0.0.1

**远程访问（未来）**：
- TLS 1.3
- mTLS 双向认证
- SSH 隧道支持

---

## 性能优化

### 1. 内存优化

**sync.Pool 复用对象**：
```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func useBuffer() *bytes.Buffer {
    buf := bufferPool.Get().(*bytes.Buffer)
    buf.Reset()
    return buf
}
```

**Context Pruning**：
- 定期剪枝历史消息
- 摘要化旧轮次
- 释放不再使用的资源

### 2. 并发优化

**Worker Pool**：
```go
type WorkerPool struct {
    tasks   chan Task
    workers int
    wg      sync.WaitGroup
}

func NewWorkerPool(workers int) *WorkerPool {
    pool := &WorkerPool{
        tasks:   make(chan Task, 100),
        workers: workers,
    }

    for i := 0; i < workers; i++ {
        pool.wg.Add(1)
        go pool.worker()
    }

    return pool
}
```

**Goroutine Leaks 预防**：
- 所有 goroutine 必监听 `context.Done()`
- 使用 `defer` 确保清理
- 定期检查 `runtime.NumGoroutine()`

### 3. I/O 优化

**零拷贝**：
```go
// 使用 io.Pipe
pr, pw := io.Pipe()
go io.Copy(pw, src)
io.Copy(dst, pr)
```

**缓冲 I/O**：
```go
// bufio.Scanner 逐行读取
scanner := bufio.NewScanner(stdout)
for scanner.Scan() {
    line := scanner.Text()
    // 处理行
}
```

### 4. Profiling

**CPU Profiling**：
```go
import (
    _ "net/http/pprof"
    "os"
    "runtime/pprof"
)

func main() {
    f, _ := os.Create("cpu.prof")
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
}
```

**Memory Profiling**：
```go
f, _ := os.Create("mem.prof")
runtime.GC()
pprof.WriteHeapProfile(f)
```

---

## 依赖库

### 核心依赖

```go
require (
    // gRPC
    google.golang.org/grpc v1.62.0
    google.golang.org/protobuf v1.32.0

    // LSP
    github.com/sourcegraph/go-lsp v0.0.0
    github.com/sourcegraph/jsonrpc2 v0.2.0

    // TUI
    github.com/charmbracelet/bubbletea v0.25.0
    github.com/charmbracelet/lipgloss v0.9.0
    github.com/charmbracelet/bubbles v0.18.0

    // 数据库
    modernc.org/sqlite v1.28.0

    // 配置
    github.com/spf13/cobra v1.8.0
    github.com/spf13/viper v1.18.0

    // 日志
    go.uber.org/zap v1.26.0
)
```

---

## 参考

- [OpenCode GitHub](https://github.com/anomalyco/opencode)
- [go-lsp](https://github.com/sourcegraph/go-lsp)
- [Bubble Tea](https://github.com/charmbracelet/bubbletea)
- [gRPC Go Quick Start](https://grpc.io/docs/languages/go/quickstart/)

---

**文档版本**: 2.0.0-dev
**最后更新**: 2026-01-17
**维护者**: Kore Team
